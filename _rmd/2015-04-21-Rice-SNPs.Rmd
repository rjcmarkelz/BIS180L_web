---
title: "Rice SNPs"
layout: lab
tags:
- R
- SNPs
hidden: true
---

## Getting Started
* Create a new directory for today's lab "SNP_GWAS_Assignment".
* Download the file [RiceSNPData.zip]({{site.baseurl}}/data/RiceSNPData.zip), and place the files in the folder that you just created.
* Start RStudio.  
* Set the working directory to the directory that you created for today's lab.  You can set the working directory by any of the following 3 methods:
    * Using the `setwd()` command 
    * Choosing "Set working directory" from the "Session" pull-down menu
    * Click on the "Files" tab in the lower right-hand pane, navigate to the folder, then choose "Set working directory" from the "More" menu in the lower right hand pane.
    
## some new functions
We will start by learning a few new functions.

### Merging data
Often we will have data in two or more spreadsheets that pertain to the same subjects.  They data may not be in the same order, and not all of the subjects may be represented in all spreadsheets. We can use the `merge()` function to help bring them together.  Lets start with some made-up data for practice.  __Adjust the paths below as needed for your setup__
```{r merge1}
fruit.size <- read.csv("../data/fruit_size.csv")
fruit.color <- read.csv("../data/fruit_color.csv")
fruit.shape <- read.csv("../data/fruit_shape.csv")

fruit.color
fruit.shape

fruit.color.shape <- merge(fruit.color,fruit.shape,by="fruit")
fruit.color.shape
```

**EXERCISE 1:** What does "by" do? In the command above (hint: look at the help page for `merge()`)

**EXERCISE 2:** Why are there only seven rows in the merged data set even though fruit.shape had nine?  Read the help page for `merge()` to figure out how to keep all of the data in the original fruit.shape data sheet.

**EXERCISE 3:** merge fruit.size with fruit.color.shape, keeping all of the rows from each original sheet.  Place the merged dataframe in `fruit.all`.  Note that the column that you want to merge on for fruit size has a different name.  Read help on `merge()` to figure out how to deal with this.

```{r reshape_prep,echo=FALSE,results='hide'}
fruit.color.shape <- merge(fruit.color,fruit.shape,by="fruit",all=T)
fruit.all <- merge(fruit.color.shape, fruit.size,by.x="fruit",by.y="name",all=T)
```

### sorting and ordering data
We can use the `sort()` function to sort any single vector of data
```{r}
sort(fruit.shape$fruit)
sort(fruit.shape$fruit,decreasing=T)
```

We can use `order()` to tell us how we could reorder the items to obtain a sorted list

```{r}
fruit.shape$fruit 
order(fruit.shape$fruit)
#order tells us that the third item (apple) should be first, the first item (bananna) should be second, etc)

#thus we can use the [] brackets to re-order things correctly.  this allows us to reorder a whole data.frame

```
**EXERCISE 4:** reorder fruit.all so that the whole data.frame is sorted by fruit shape.  Your output should look like:
```{r echo=FALSE}
fruit.all[order(fruit.all$shape),]
```

**EXERCISE 5:** reorder fruit.all so that the whole data.frame is sorted by fruit size, then by fruit shape. (hint: look at help for order)  Your output should look like:
```{r echo=FALSE}
fruit.all[order(fruit.all$size,fruit.all$shape),]
```

### reshaping data.
The fruit.color.shape.size data frame that you have created one row for each fruit type and one column for each measurement type.  This is called the "wide" format.  Often in R you will want data to be in a "long" format, where each row represents a single observation.  The `melt()` function in the reshape library can convert wide to long:

```{r melt,eval=FALSE}
library(reshape2)
fruit.all

#id.var specifies which column holds identifying information instead of measurements.
#you could use meas.var instead. to specify which columns hold measurements
fruit.all.melt <- melt(fruit.all,id.var="fruit") 
fruit.all.melt
```
You can find more information on reshaping data via a webpage that I wrote [here](http://mfcovington.github.io/r_club/resources/2013/03/28/Reshape/)

### applying functions across rows or columns
It is very common to want to apply a function to each row.  We can use the `apply()` function for this.  `apply` takes at least 3 arguments.

`apply(X,MARGIN,FUN)`
where
* X is a data frame or matrix
* MARGIN is whether to apply a function to each row (1) or each column (2)
* FUN is the function that you want to use

For example
```{r}
m <- matrix(rnorm(24),ncol=6) #create a matrix of numbers to illustrate apply
m
apply(m,1,min) # find the minimum value of each row
```

**EXERCISE 6:** find the mean of each column of m

## Lets get started with the real data
### Data Import
You learned how to import data last week using `read.csv()`.  Today we will provide two additional arguments to that function:
```{r import_geno, results='hide', eval=TRUE}
data.geno <- read.csv("../data/Rice_44K_genotypes.csv.gz",
                      row.names=1, #this tells R to use the first column as row names
                      na.strings=c("NA","00")) #this tells R that missing data is denoted as "NA" or "00"

#Takes a minute or two to load
```

Use `dim()` to determine the numbers of rows and columns.  (You can also look at the info in the right-hand pane).  There are 413 rows and 36,901 columns.  Generally I recommend looking at files after they have been read in with the `head()` and `summary()` functions but here we must limit ourselve to looking at a subset of what we read in.
```{r summary, eval=FALSE}
head(data.geno[,1:20]) #first six rows of first 20 columns
summary(data.geno[,1:20]) #summarizes the first 20 columns
```
In this file each row represents a different rice variety and each column a different SNP. The row names ("NSFTV1") give the ID of each variety.  The column names give the chromosome and locations of each SNP.  For example, "X1_151492" is a SNP on chromosome 1, base position 151492.

### An MDS Plot.  
Multi-Dimensional Scaling (MDS) plots can be used to display the genetic diversity in a 2D space.  The full 36,901 SNPs take too long to run for this class so we will subset the data.  

Using the techniques that you learned last week, create a data subset that contains a random sample of 2500 SNPs from the full dataset.  Place the smaller data set in an object called `data.geno.2500`

Check the dimensions of your subset.  If you don't get the output below, you did something wrong:

```{r subset,echo=FALSE, results='hide'}
#first create a smaller dataset by randomly picking 2500 columns
data.geno.2500 <- data.geno[,sample(x=1:ncol(data.geno),size=2500)]
```

```{r check_subset}
dim(data.geno.2500)
```

Now that we have our smaller subset we can create the MDS plot
```{r MDS, eval=FALSE}
#convert the data matrix to numbers
geno.numeric <- data.matrix(data.geno.2500)
head(geno.numeric[,1:20])

#calculate the Euclidian distance between each rice variety
genDist <- as.matrix(dist(geno.numeric))

#perform the multi-dimensional scaling
geno.mds <- as.data.frame(cmdscale(genDist))
head(geno.mds) #now we have 2 dimensions
```
`geno.mds` contains the genotypic information rescaled to display in two dimensions.  Now lets plot it.  Use one of the plotting functions that you learned about last week to make a x-y scatter plot of the data, with "V1" on one axis and "V2" on the other axis.

```{r mdsPlot, results='hide', eval=FALSE, echo=FALSE}
library(ggplot2) #helpful plotting routines
qplot(x=V1,y=V2,data=geno.mds,geom="point")
```

**EXERCISE 7:** Is there any evidence for populations structure (different sub populations)?  If so, how many sub populations do you think the MDS plot reveals?  What do you make of the individuals that are between the major groups?  You may want to include this figure and a discussion of it in your lab report.

```{r PCA_Alternative, eval=FALSE,echo=FALSE}
##Alternative method for PCA
##Not used 2013

#you must reduce the number of SNPS to be < = the number of observations
geno.small <- geno.numeric[,sample(1:nrow(geno.numeric),size=nrow(geno.numeric))]
geno.small[is.na(geno.small)] <- 0 #missing values not allowed
geno.pc <- prcomp(geno.small)

#Show variance explained by top PCs
plot(geno.pc)

#The PCs themselves are here
head(geno.pc$x)

#you can relate back to the original SNPs by:
head(geno.pc$rotation) #tell you how much each SNP contributed to each PC

pheno.PC <- merge(data.pheno,geno.pc$x,by="row.names")

library(ggplot2)
qplot(x=PC1,y=PC2,color=Region,data=pheno.PC) + scale_color_brewer(type="div")
qplot(x=PC1,y=PC3,color=Region,data=pheno.PC) + scale_color_brewer(type="div")
```

### Adding phenotypes

The file "RiceDiversity.44K.MSU6.Phenotypes.csv" contains information about the country of origin and phenotypes of most of these varieties.  

**EXERCISE 8:** Use the `read.csv()` `head()` and `summary()` functions that you learned earlier to import and look at this file.  Import the file into an object called "data.pheno".  In this case you do no need to limit yourself to the first 20 columns, so do not include [,1:20] in your arguments for head and summary.
```{r read_pheno, echo=FALSE, results='hide', eval=FALSE}
data.pheno <- read.csv("RiceDiversity.44K.MSU6.Phenotypes.csv",row.names=1)
head(data.pheno)
summary(data.pheno)
```

**EXERCISE 9:** Use merge() to merge the MDS scaled genotype data with the phenotype data.  Here the column that we are merging on is the "row.name" column.  So you can use `by="row.names"` or `by=1` in your call to merge.  Use summary and head to look at the new object and make sure that it is as you expect.

```{r merge, results='hide', eval=FALSE, echo=FALSE}
data.pheno.mds <- merge(geno.mds,data.pheno,by="row.names",all=T)
```


```{r check_merge, results='hide',echo=FALSE, eval=FALSE}
summary(data.pheno.mds)
head(data.pheno.mds)
```
We can now color points on our plot by characteristics in this data set.  

**EXERCISE 10:** Prepare three different plots to explore if subgroups vary by 1) Amylose content; 2) Pericarp color; 3) Region.  Do any of these seem to be associated with the different popilation groups? You may want to include a discussion of this in your lab report

*Hint 1* use `color=` argument to qplot or ggplot to color the point by the different traits

*Hint 2* use `size=I(3)` as an argument to increase the point size (you can play with different values)

*Hint 3* when plotting the Region data, the colors will be easier to interpret if you include the folowing at the end of the line with your qplot command: ` + scale_color_brewer(type="div")` This specifies that a diverging set of colors is used.  (Try plotting with and without this).


```{r MDS_color, results='hide', eval=FALSE,echo=FALSE}
qplot(x=V1,y=V2,color=Amylose.content,data=data.pheno.mds,size=I(3))
qplot(x=V1,y=V2,color=Pericarp.color,data=data.pheno.mds,size=I(3))
qplot(x=V1,y=V2,color=Region,data=data.pheno.mds,size=I(3))
```


## PSMix: Assigning varieties to populations.
From the MDS plot it looks like there is structure in our population.  But how do we know which individual belongs in which population?  We can take an alternative approach and assign individuals to specific population classes with [PSMix](http://www.biomedcentral.com/1471-2105/7/317) package.

First we have to convert our genotypes to the form that PSMix expects.  PSMix wants a separate row for each allele (two rows for each variety).  A couple of the commands below are a bit complex.  I will explain them in lab after this has been run.

```{r convert_PSMix, results='hide',eval=FALSE}
#Convert to character matrix.  The apply function applies a function (in this case as.character) either to every column or every row in the data.
data.geno.2500.c <- apply(data.geno.2500,2,as.character)

#Create a new Matrix to hold reformatted data
data.geno.2500.ps <- matrix("",nrow=nrow(data.geno.2500.c)*2,ncol=ncol(data.geno.2500.c))

#for each row of genotypes, create 2 rows, one with the first allele and one with the second allele.
for (i in 1:nrow(data.geno.2500.c)) {
  data.geno.2500.ps[(i-1)*2+1,] <- substr(data.geno.2500.c[i,],1,1)
  data.geno.2500.ps[(i-1)*2+2,] <- substr(data.geno.2500.c[i,],2,2)
  }
```
Now we can run PSMix.  PSMix will determine the proportion of each individual's genome that came from one of K ancesteral populations.  This can take a long time to run, so you can just import the results of my previous run of the analysis if you prefer

```{r PSMix5,results='hide',eval=FALSE}
install.packages("PSMix") #only needs to be done once per machine
library(PSMix)

#load in my pre-run data
load("ps4.2500.RData")

#if you prefer, uncomment the lines below to run on your own.
#run on K=4 popultions and 2500 markers; may take 15-30 minutes
#system.time(ps4 <- PSMix(K=4,data.geno.2500.ps,eps=1e-05,verbose=T))
#save(ps4,file="ps4.2500.RData")

#2500 markers K = 5 > 1 hour run time
#system.time(ps5 <- PSMix(K=5,data.geno.2500.ps,eps=1e-05,verbose=T))
#save(ps5,file="ps5.2500.RData")
```

Now examine the output
```{r PSMix_out,results='hide',eval=FALSE}
names(ps4) #shows us elements within ps4
#AmPr is the proportion of the genome that came from each ancestral population
head(ps4$AmPr) 
round(head(ps4$AmPr),3) #round to 3 decimal places to make it easier to see
#Genomes with substantial contributions from two ancestral genomes are said to be admixed
#AmID assigns each individual to one of the ancestral populations
head(ps4$AmId)
```

If you want to know how many individuals were assigned to each population, you can use `table()`
```{r table,eval=FALSE}
table(ps4$AmId)
```

The PSMix output must be reformatted in order to plot it well.  Not all of the commands are fully explained below.  If you have questions we can go over this in Friday's discussion.

The first step is to combine the useful columns from PSMix together into a single data frame.  This is accomplished using `cbind()` ("column bind") to paste the columns together.
```{r ps_reformat1, results='hide',eval=FALSE}
ps4.df <- as.data.frame(cbind(round(ps4$AmPr,3),ps4$AmId))
head(ps4.df) #look at the new data frame

#Next add useful column names
colnames(ps4.df) <- c(paste("pop",1:(ncol(ps4.df)-1),sep=""),"popID")
head(ps4.df) #look at the new data frame
```

For plotting it will be helpful to order the samples based on population identity and composition.  First we calculate the largest proportion of the genome from a single ancestral population for each individual.  This is done using `apply()`, which *applies* a function across every row or column of a data frame.  

The first argument to apply specifies the matrix or data frame to work on; the second is the dimension to apply (1 = rows, 2 = columns); the third is the function to apply.  So below, we find the maximum contribution that any single ancestral genome is predicted to have been made for each rice variety.  The larger this number, the less admixture.

```{r ps_reformat2,results='hide',eval=FALSE}
maxGenome <- apply(ps4$AmPr,1,max) 

#now we order the varieties by their prediced population membership and their degree of admixture.
ps4.df <- ps4.df[order(ps4.df$popID,-maxGenome),]
#Add a column for sample index
ps4.df$sampleID <- factor(1:413)
head(ps4.df)
```

The next step is to take the data from "wide" format to "long" format.  `qplot()` needs one observation per row, whereas now we have 5 observations per row.  We use `melt()` as described at the beginning of this tutorial.
```{r ps_reformat3,results='hide',eval=FALSE}
library(reshape2)
ps4.df.melt <- melt(ps4.df,id.vars=c("popID","sampleID"))
head(ps4.df.melt) #look a the melted data set.
```

Finally we are ready to plot the results.  In the plot produced below, each column is a single rice variety. The colors correspond to ancestral genomes.  Do you see any evidence of admixture?
```{r plot_PSMix data,results='hide',eval=FALSE}
library(ggplot2)
qplot(x=sampleID, y=value, color=variable, fill=variable, data=ps4.df.melt, geom="bar", stat="identity") + ylab("genome proportion") + scale_color_brewer(type="div") + scale_fill_brewer(type="div")
```

### How do these population assignments relate to the MDS plot? 

It would be interesting to see how the assigned population ancestry relates to the MDS plot.  You can add the population predictions to the mds information using this code:
```{r AddpopToMDS,results='hide',eval=FALSE}
geno.mds$popID <- factor(ps4$AmId) #this only works because the order of the varieties is the same in geno.mds and ps4
head(geno.mds$popID)
#Also add the admixture proportions for future use
#first give them some useful names
colnames(ps4$AmPr) <- paste("pr",1:4,sep="")

geno.mds <- cbind(geno.mds,ps4$AmPr)
head(geno.mds)
```

**EXERCISE 11:** Replot the MDS data, but include the population assignment in an informative way.  How do the populations assignments relate to the MDS plot?

```{r eval=FALSE,echo=FALSE}
qplot(x=V1,y=V2,color=popID,data=geno.mds,geom="point",size=I(3)) + scale_color_brewer(type="div")
```


